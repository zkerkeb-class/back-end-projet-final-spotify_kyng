const fs = require('fs').promises;
const path = require('path');
const sharp = require('sharp');
const logger = require('../utils/logger');

async function generateOptimizedVersions(fileBuffer, originalFileName) {
  logger.info("üé® D√©but de l'optimisation des images");

  // 1. CONFIGURATION
  const sizes = {
    200: 200,
    400: 400,
    800: 800,
  };

  const formats = {
    jpeg: { quality: 80, mozjpeg: true },
    // webp: { quality: 80 }
  };

  try {
    // 2. V√âRIFICATIONS PR√âLIMINAIRES
    const outputDir = path.join(__dirname, '..', 'cdn', 'uploadsImage', 'optimized');
    await fs.mkdir(outputDir, { recursive: true });

    logger.debug(
      {
        sizes: Object.keys(sizes),
        formats: Object.keys(formats),
      },
      "‚öôÔ∏è Configuration de l'optimisation"
    );

    // 3. TRAITEMENT DES IMAGES
    const resultats = await Promise.all(
      Object.entries(sizes).flatMap(async ([nomTaille, taille]) => {
        return await Promise.all(
          Object.entries(formats).map(async ([format, options]) => {
            const nomFichier = path.basename(originalFileName, path.extname(originalFileName));
            const cheminSortie = path.join(outputDir, `${nomFichier}_${nomTaille}.${format}`);

            try {
              logger.debug(
                `Traitement de l'image pour la taille ${nomTaille} et le format ${format}`
              );

              const resultat = await sharp(fileBuffer)
                .resize(taille, taille, { fit: 'inside', withoutEnlargement: true })
                .toFormat(format, options)
                .toFile(cheminSortie);

              logger.debug(
                {
                  size: nomTaille,
                  format: format,
                  path: cheminSortie,
                },
                '‚ú® Version optimis√©e g√©n√©r√©e'
              );

              return {
                taille: nomTaille,
                format: format,
                path: cheminSortie,
                largeur: resultat.width,
                hauteur: resultat.height,
              };
            } catch (erreur) {
              logger.error(
                {
                  error: erreur.message,
                  size: nomTaille,
                  format: format,
                },
                "‚ùå √âchec de g√©n√©ration d'une version"
              );
              return null;
            }
          })
        );
      })
    );

    // Filtrer les r√©sultats null
    const versions = resultats.flat().filter(Boolean);

    logger.info(
      {
        versionsCount: versions.length,
      },
      '‚úÖ Optimisation termin√©e avec succ√®s'
    );

    // 4. RETOUR DES R√âSULTATS
    return {
      succes: true,
      nombreVersions: versions.length,
      versions: versions,
    };
  } catch (erreur) {
    logger.error(
      {
        error: erreur.message,
        stack: erreur.stack,
      },
      "üí• Erreur fatale lors de l'optimisation"
    );
    throw new Error("√âchec de l'optimisation de l'image");
  }
}

module.exports = { generateOptimizedVersions };
